<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=340, user-scalable=0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <script src="jquery.min.js"></script>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }
        #t ul {
            list-style-type: none;
            width: 90px;
            height: 90px;
            background: #000;
            position: relative;
        }
        #t ul>li {
            position: absolute;
            width: 20px;
            height: 20px;
            margin: 5px;
            text-align: center;
            line-height: 20px;
            background: #f00;
        }
        #t ul>li._0 {
            background: rgba(0, 0, 0, 0);
        }
    </style>
</head>
<body>
    <div style="width: 100%; text-align: center;">
        <br />
        <div id="t" style="margin: auto; width: 90px;"></div>
    </div>
    <script type="text/javascript">
        var DATA = '1,2,3,4,5,6,7,8,0';
        var W = 3;
        var H = DATA.split(',').length / W;
        var R = r(DATA);

        var elementData;
        var eventQueue = [];

        function h(data) {
            var a = data.split(',');
            var r = 0;
            for (var i = 0; i < a.length; i++) {
                r += function (a, b) {
                    return Math.sqrt(Math.pow(parseInt(a / W) - parseInt(b / W), 2) + Math.pow((a % W) - (b % W), 2));
                } ((i + 1) % a.length, parseInt(a[i]));
            }
            return r;
        }
        
        // A*
        //
        // 1.从 open 中取出最小的 f 值节点放入 closed 中
        // 2.计算 上下左右移动的 f 值即当前的 g 值加上估算值 h 并将节点放入 open 中（新节点在 closed 中啥也不干, 新节点在 open 中则对其更新, 设置父节点）
        // 3.若未完成搜索则回到 1
        // 4.输出路径
        function contains(a, data) {
            for (var i = 0; i < a.length; i++) {
                if (a[i].data == data) {
                    return i;
                }
            }
        }

        function s(open, _closed, parent, pos, newPos) {
            // 新节点在 closed 中啥也不干, 新节点在 open 中则对其更新
            var a = parent.data.split(',');
            a[pos] = a[newPos];
            a[newPos] = '0';
            var data = a.join(',');
            if (contains(_closed, data) == undefined) {
                var g = parent.g + 1;
                var f = g + h(data);
                var i = contains(open, data);
                if (i != undefined) {
                    if (f < open[i].f) {
                        open[i].parent = parent;
                        open[i].f = f;
                        open[i].g = g;
                        open[i].p = [ pos, newPos ];
                    }
                } else {
                    var n = {
                        data: data,
                        parent: parent,
                        f: f,
                        g: g,
                        p: [ pos, newPos ]
                    };
                    open.push(n);
                    if (f == g) {
                        return n;
                    }
                }
            }
        }

        function r(data) {
            var a = data.split(',');
            var s = 0;
            var p;
            for (var i = 0; i < a.length; i++) {
                if (!parseInt(a[i])) {
                    p = i;
                }
                for (var j = 0; j < i; j++) {
                    if (parseInt(a[i]) < parseInt(a[j])) {
                        s++;
                    }
                }
            }
            return s + parseInt(p / W) + p % W;
        }

        function random() {
            var data;
            do {
                var a = DATA.split(',');
                for (var i = 0; i < a.length / 2; i++) {
                    var p = parseInt(Math.random() * a.length);
                    var t = a[p];
                    a[p] = a[0];
                    a[0] = t;
                }
            } while (r(data = a.join(',')) % 2 != R % 2);
            return data;
        }

        function search(data, cb) {
            var open = [{ data: data, f: h(data), g: 0 }];
            if (!open[0].f) {
                cb(open[0]);
            } else {
                var _closed = [];
                var handle = setInterval(function () {
                    if (open.length > 0) {
                        // 1.从 open 中取出最小的 f 值节点放入 closed 中
                        var p = 0;
                        for (var i = 1; i < open.length; i++) {
                            if (open[i].f < open[p].f) {
                                p = i;
                            }
                        }
                        var n = open.splice(p, 1)[0];
                        _closed.push(n);
                        // 2.计算 上下左右移动的 f 值即当前的 g 值加上估算值 h 并将节点放入 open 中
                        var pos = function (a) {
                            for (var i = 0; i < a.length; i++) {
                                if (parseInt(a[i]) == 0) {
                                    return i;
                                }
                            }
                        } (n.data.split(','));
                        var x = pos % W;
                        var y = parseInt(pos / W);
                        var t;
                        if (x > 0) {
                            if (t = s(open, _closed, n, pos, (x - 1) + y * W)) {
                                clearInterval(handle);
                                cb(t);
                                return ;
                            }
                        }
                        if (x < W - 1) {
                            if (t = s(open, _closed, n, pos, (x + 1) + y * W)) {
                                clearInterval(handle);
                                cb(t);
                                return ;
                            }
                        }
                        if (y > 0) {
                            if (t = s(open, _closed, n, pos, x + (y - 1) * W)) {
                                clearInterval(handle);
                                cb(t);
                                return ;
                            }
                        }
                        if (y < H - 1) {
                            if (t = s(open, _closed, n, pos, x + (y + 1) * W)) {
                                clearInterval(handle);
                                cb(t);
                            }
                        }
                    }
                }, 1);
            }
        }

        function animate() {
            if (eventQueue.length) {
                var event = eventQueue.splice(0, 1)[0];
                var t = elementData.elements[event[0]];
                elementData.elements[event[0]] = elementData.elements[event[1]];
                elementData.elements[event[1]] = t;
                {
                    // 更新
                    var a = elementData.data.split(',');
                    var t = a[event[0]];
                    a[event[0]] = a[event[1]];
                    a[event[1]] = t;
                    elementData.data = a.join(',');
                }
                var c = 0;
                $.each(elementData.elements, function (i, element) {
                    $(element).animate({
                        left: (i % W) * elementData.w + 'px',
                        top: parseInt(i / W) * elementData.h + 'px'
                    }, 'fast', 'linear', function () {
                        if (++c == elementData.elements.length) {
                            animate();
                        }
                    });
                });
            }
        }

        $(function() {
            // 初始化
            var t = '';
            var data = random();
            var a = data.split(',');
            for (var i = 0; i < a.length; i++) {
                t += parseInt(a[i]) ? '<li>' + a[i] + '</li>' : '<li class="_0"></li>';
            }
            $('#t').html('<ul>' + t + '</ul>');
            elementData = { elements: $('#t li'), data: data, w: $('#t ul').outerWidth() / W, h: $('#t ul').outerHeight() / H };
            $.each(elementData.elements, function (i, element) {
                $(element).css({
                    left: (i % W) * elementData.w + 'px',
                    top: parseInt(i / W) * elementData.h + 'px'
                })
            });
            
            search(data, function (n) {
                do {
                    eventQueue.splice(0 , 0, n.p);
                    n = n.parent;
                } while (n.p);
                animate();
            });
        });

        // function format(data) {
        //     var a = data.split(',');
        //     var t = '';
        //     for (var i = 0; i < a.length; i++) {
        //         if (!parseInt(a[i])) {
        //             t += '<li style="background: #ff0;"></li>';
        //         } else {
        //             t += '<li>' + a[i] + '</li>';
        //         }
        //     }
        //     return '<ul>' + t + '</ul>';
        // }
        //
        // '3,2,7,4,5,1,10,8,9,6,0,12,13,14,11,15'
        // search(random(), function (n) {
        //     var t = format(n.data);
        //     while (n = n.parent) {
        //         t = format(n.data) + '<br/>' + t;
        //     }
        //     document.getElementById('t').innerHTML = '<br/>' + t;
        // });
    </script>
</body>
</html>